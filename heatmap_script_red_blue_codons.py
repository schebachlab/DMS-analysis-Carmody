#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
heatmap_script.py

This short program reads in an excel sheet generated by the dms functions
script dms_script_functions.py and creates a heat map of the weighted
intensities. This was necessary to put into a separate script in order
to avoid a strange bug that appeared when trying to do this in the main script

@author: Charles Kuntz :: cpkuntz@iu.edu
"""

# Parse the excel sheet and return a dataframe
def excel_parser_func(excel_workbook):
    import pandas as p
    pd_df = pd.read_excel(excel_workbook, header=0, index_col=0)
    return pd_df

# Apply a cap to a dataframe using applymap method
def apply_cap_func(pd_df, cap):
    
    def adjustment(x):
        if type(x) is str:
            return x
        elif x >cap:
            return cap
        elif x <cap:
            return x
        else:
            return
    
    pd_df_capped = pd_df.applymap(adjustment)
    return pd_df_capped  

# Write a heat map. Function is passed a single dataframe
def write_heatmap_func(dataframe, num_columns, enforce_squares, scale_min, scale_max, scale_center, line_scale, figurename, figure_res):
    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns
    sns.set(font_scale=2)
    mask = dataframe.isnull()
    size_width = num_columns
    size_height = 15
    plt.figure(figsize=(size_width, size_height))
    if enforce_squares == True:
        with sns.axes_style("dark"):
            heat_map = sns.heatmap(dataframe, vmin = scale_min, vmax = scale_max, center = scale_center, linewidths = line_scale, linecolor = 'black', square=True, cmap = 'bwr')
            #heat_map = sns.heatmap(dataframe, center = 1, linewidths = 0.5, linecolor = 'black', square=True, cmap = 'bwr')
    else:
        with sns.axes_style("dark"):
            heat_map = sns.heatmap(dataframe, vmin = scale_min, vmax = scale_max, center = scale_center, linewidths = line_scale, linecolor = 'black', cmap = 'bwr')
    heat_map.set_facecolor('black')
    figure = heat_map.get_figure()
    figure.savefig(str(figurename), dpi=figure_res)
    #plt.savefig(str(figurename), dpi=1200)
    return heat_map

def genetic_code_func():
    import re
    genetic_code  = """
        TTT F      CTT L      ATT I      GTT V
        TTC F      CTC L      ATC I      GTC V
        TTA L      CTA L      ATA I      GTA V
        TTG L      CTG L      ATG M      GTG V
        TCT S      CCT P      ACT T      GCT A
        TCC S      CCC P      ACC T      GCC A
        TCA S      CCA P      ACA T      GCA A
        TCG S      CCG P      ACG T      GCG A
        TAT Y      CAT H      AAT N      GAT D
        TAC Y      CAC H      AAC N      GAC D
        TAA Stop   CAA Q      AAA K      GAA E
        TAG Stop   CAG Q      AAG K      GAG E
        TGT C      CGT R      AGT S      GGT G
        TGC C      CGC R      AGC S      GGC G
        TGA Stop   CGA R      AGA R      GGA G
        TGG W      CGG R      AGG R      GGG G
        """
    codon_finder = re.compile(r'[ATCG]{3}')
    amino_acid_finder = re.compile(r'\ \w{1}[\ |\n]|\Stop')
    codon_list = codon_finder.findall(genetic_code)
    amino_acid_list = [x.strip() for x in amino_acid_finder.findall(genetic_code)]
    genetic_code_dict = {}
    i = 0
    while i < len(codon_list):
        genetic_code_dict[codon_list[i]] = amino_acid_list[i]
        i += 1
    return genetic_code_dict

def domain_processor(domain_sequence_raw):
    import textwrap
    import re
    domain_sequence = re.sub("[^a-zA-Z]", "", domain_sequence_raw)
    domain_codons = textwrap.wrap(domain_sequence, 3)
    domain_length = len(domain_sequence)
    return domain_sequence, domain_codons, domain_length

def ribosome(domain_codons, genetic_code_dict):
    domain_aminoacids = []
    for codon in domain_codons:
        amino_acid = genetic_code_dict[codon]
        domain_aminoacids.append(amino_acid)
    return domain_aminoacids

# Main function
if __name__ == '__main__':

    # Load libraries
    import sys
    import os
    import numpy as np
    import pandas as pd
    import seaborn as sns
    

    # Ask user for path to excel file:
    path_to_excel_sheet = str(input("Please enter path to excel workbook: "))

    while True:
        analysis_choice = int(input("Do you want to map\n[1] amino acid substitutions\n[2] codon substitutions or\n[3] nucleotide substitutions?\nPlease enter [1], [2], or [3]: "))
        if analysis_choice == 1:
            break
        elif analysis_choice == 2:
            break
        elif analysis_choice == 3:
            break
        else:
            print("Input error. Please enter [1], [2], or [3]")



    # Get the WT sequence
    wtseq = str(input("Please enter the sequence of the WT domain: "))

    # Ask user for figure name:
    print("Enter a name and include an extension for the file type. File types available:")
    print("eps, pdf, pgf, png, ps, raw, rgba, svg, svgzâ€‹")
    figurename = str(input("Please enter a name for this figure: "))

    # Some answers to yes or no questions:
    yes_conditions = ['Yes', 'Y', 'y', 'yes', 'YES', 'yeah', 'uh huh', 'sure', 'alright', 'yea',
                      'yES', 'yeS', 'YEs', 'oui', 'Oui', 'aye', 'Aye', 'Sure', 'yep', 'Yep', 'Yea']
    no_conditions = ['No', 'N', 'n', 'no', 'NO', 'nah', 'nope', 'Nope', 'No way','NOT', 'mmm mmm',
                     'nO', 'Non', 'non', 'nay', 'Nay', 'nada', 'I don\'t think so', 'Nada']

    while True:
        squares_switch_inp = str(input("Would you like to enforce squares in the heatmap? Yes or no: "))
        if squares_switch_inp in yes_conditions:
            squares_switch = True
            break
        elif squares_switch_inp in no_conditions:
            squares_switch = False
            break
        else:
            print("Answer must be yes or no. Please re-enter.")


    # Ask the user if they want to cap the data:
    while True:
        cap_switch_inp = str(input("Would you like to apply a cap to the data? Yes or no: "))
        if cap_switch_inp in yes_conditions:
            cap_switch = True
            break
        elif cap_switch_inp in no_conditions:
            cap_switch = False
            break
        else:
            print("Answer must be yes or no. Please re-enter.")

    # Set the cap
    if cap_switch == True:
        cap = float(input("Please enter a cap for the heat map values: "))

    print("Please enter the scale parameters for the color gradient...")
    scale_min = float(input("Enter the minimum value (blue) of the color gradient scale: "))
    scale_max = float(input("Enter the maximum value (red) of the color gradient scale: "))
    scale_center = float(input("Enter the center value (white) of the scale: "))
    
    print("Please enter the line width in pts for square boundaries. 1 pt lines are a good choice. 0.25 really thin. Try 0 for no lines.")
    line_scale = float(input("Line width: "))
    
    figure_res = int(input("Enter resolution in dots per inch: "))

    # Get the genetic code:
    genetic_code_dict = genetic_code_func()

    # Process the WT sequence
    domain_seq, domain_codons, seqlen = domain_processor(wtseq)
    domain_translated = ribosome(domain_codons, genetic_code_dict)

    domain_list = list(domain_seq)

    # Load the excel sheet as a dataframe:
    dataframe_in = excel_parser_func(path_to_excel_sheet)

    # Apply cap if necessary
    if cap_switch == True:
        dataframe = apply_cap_func(dataframe_in, cap)
    else:
        dataframe = dataframe_in

    #print(dataframe)

    # Reindex the dataframe
    
    if analysis_choice == 1:
        dataframe.columns = domain_translated
        num_columns = len(domain_translated)
    elif analysis_choice == 2:
        dataframe.columns = domain_codons
        num_columns = len(domain_codons)
    else:
        dataframe.columns = domain_list
        num_columns = len(domain_list)

    # Create the heat map:
    write_heatmap_func(dataframe, num_columns, squares_switch, scale_min, scale_max, scale_center, line_scale, figurename, figure_res)


